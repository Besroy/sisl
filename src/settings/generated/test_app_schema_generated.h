// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TESTAPPSCHEMA_TESTAPP_H_
#define FLATBUFFERS_GENERATED_TESTAPPSCHEMA_TESTAPP_H_

#include "flatbuffers/flatbuffers.h"

#include "utility/non_null_ptr.hpp"

namespace testapp {

struct DatabaseSettings;
struct DatabaseSettingsT;

struct DBConnection;
struct DBConnectionT;

struct Glog;
struct GlogT;

struct Config;
struct ConfigT;

struct TestAppSettings;
struct TestAppSettingsT;

inline const flatbuffers::TypeTable *DatabaseSettingsTypeTable();

inline const flatbuffers::TypeTable *DBConnectionTypeTable();

inline const flatbuffers::TypeTable *GlogTypeTable();

inline const flatbuffers::TypeTable *ConfigTypeTable();

inline const flatbuffers::TypeTable *TestAppSettingsTypeTable();

struct DatabaseSettingsT : public flatbuffers::NativeTable {
  typedef DatabaseSettings TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.DatabaseSettingsT";
  }
  std::string databaseHost;
  uint32_t databasePort;
  uint32_t numThreads;
  DatabaseSettingsT()
      : databasePort(27017),
        numThreads(8) {
  }
};

struct DatabaseSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DatabaseSettingsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DatabaseSettingsTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.DatabaseSettings";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATABASEHOST = 4,
    VT_DATABASEPORT = 6,
    VT_NUMTHREADS = 8
  };
  const flatbuffers::String *databaseHost() const {
    return GetPointer<const flatbuffers::String *>(VT_DATABASEHOST);
  }
  flatbuffers::String *mutable_databaseHost() {
    return GetPointer<flatbuffers::String *>(VT_DATABASEHOST);
  }
  uint32_t databasePort() const {
    return GetField<uint32_t>(VT_DATABASEPORT, 27017);
  }
  bool mutate_databasePort(uint32_t _databasePort) {
    return SetField<uint32_t>(VT_DATABASEPORT, _databasePort, 27017);
  }
  uint32_t numThreads() const {
    return GetField<uint32_t>(VT_NUMTHREADS, 8);
  }
  bool mutate_numThreads(uint32_t _numThreads) {
    return SetField<uint32_t>(VT_NUMTHREADS, _numThreads, 8);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATABASEHOST) &&
           verifier.VerifyString(databaseHost()) &&
           VerifyField<uint32_t>(verifier, VT_DATABASEPORT) &&
           VerifyField<uint32_t>(verifier, VT_NUMTHREADS) &&
           verifier.EndTable();
  }
  DatabaseSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DatabaseSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DatabaseSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatabaseSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DatabaseSettingsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_databaseHost(flatbuffers::Offset<flatbuffers::String> databaseHost) {
    fbb_.AddOffset(DatabaseSettings::VT_DATABASEHOST, databaseHost);
  }
  void add_databasePort(uint32_t databasePort) {
    fbb_.AddElement<uint32_t>(DatabaseSettings::VT_DATABASEPORT, databasePort, 27017);
  }
  void add_numThreads(uint32_t numThreads) {
    fbb_.AddElement<uint32_t>(DatabaseSettings::VT_NUMTHREADS, numThreads, 8);
  }
  explicit DatabaseSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DatabaseSettingsBuilder &operator=(const DatabaseSettingsBuilder &);
  flatbuffers::Offset<DatabaseSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DatabaseSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<DatabaseSettings> CreateDatabaseSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> databaseHost = 0,
    uint32_t databasePort = 27017,
    uint32_t numThreads = 8) {
  DatabaseSettingsBuilder builder_(_fbb);
  builder_.add_numThreads(numThreads);
  builder_.add_databasePort(databasePort);
  builder_.add_databaseHost(databaseHost);
  return builder_.Finish();
}

inline flatbuffers::Offset<DatabaseSettings> CreateDatabaseSettingsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *databaseHost = nullptr,
    uint32_t databasePort = 27017,
    uint32_t numThreads = 8) {
  auto databaseHost__ = databaseHost ? _fbb.CreateString(databaseHost) : 0;
  return testapp::CreateDatabaseSettings(
      _fbb,
      databaseHost__,
      databasePort,
      numThreads);
}

flatbuffers::Offset<DatabaseSettings> CreateDatabaseSettings(flatbuffers::FlatBufferBuilder &_fbb, const DatabaseSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DBConnectionT : public flatbuffers::NativeTable {
  typedef DBConnection TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.DBConnectionT";
  }
  uint32_t minDBConnections;
  uint32_t maxDBConnections;
  uint64_t dbConnectionOptimalLoad;
  DBConnectionT()
      : minDBConnections(2),
        maxDBConnections(10),
        dbConnectionOptimalLoad(100) {
  }
};

struct DBConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DBConnectionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DBConnectionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.DBConnection";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINDBCONNECTIONS = 4,
    VT_MAXDBCONNECTIONS = 6,
    VT_DBCONNECTIONOPTIMALLOAD = 8
  };
  uint32_t minDBConnections() const {
    return GetField<uint32_t>(VT_MINDBCONNECTIONS, 2);
  }
  bool mutate_minDBConnections(uint32_t _minDBConnections) {
    return SetField<uint32_t>(VT_MINDBCONNECTIONS, _minDBConnections, 2);
  }
  uint32_t maxDBConnections() const {
    return GetField<uint32_t>(VT_MAXDBCONNECTIONS, 10);
  }
  bool mutate_maxDBConnections(uint32_t _maxDBConnections) {
    return SetField<uint32_t>(VT_MAXDBCONNECTIONS, _maxDBConnections, 10);
  }
  uint64_t dbConnectionOptimalLoad() const {
    return GetField<uint64_t>(VT_DBCONNECTIONOPTIMALLOAD, 100);
  }
  bool mutate_dbConnectionOptimalLoad(uint64_t _dbConnectionOptimalLoad) {
    return SetField<uint64_t>(VT_DBCONNECTIONOPTIMALLOAD, _dbConnectionOptimalLoad, 100);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MINDBCONNECTIONS) &&
           VerifyField<uint32_t>(verifier, VT_MAXDBCONNECTIONS) &&
           VerifyField<uint64_t>(verifier, VT_DBCONNECTIONOPTIMALLOAD) &&
           verifier.EndTable();
  }
  DBConnectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DBConnectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DBConnection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DBConnectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DBConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minDBConnections(uint32_t minDBConnections) {
    fbb_.AddElement<uint32_t>(DBConnection::VT_MINDBCONNECTIONS, minDBConnections, 2);
  }
  void add_maxDBConnections(uint32_t maxDBConnections) {
    fbb_.AddElement<uint32_t>(DBConnection::VT_MAXDBCONNECTIONS, maxDBConnections, 10);
  }
  void add_dbConnectionOptimalLoad(uint64_t dbConnectionOptimalLoad) {
    fbb_.AddElement<uint64_t>(DBConnection::VT_DBCONNECTIONOPTIMALLOAD, dbConnectionOptimalLoad, 100);
  }
  explicit DBConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DBConnectionBuilder &operator=(const DBConnectionBuilder &);
  flatbuffers::Offset<DBConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DBConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<DBConnection> CreateDBConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t minDBConnections = 2,
    uint32_t maxDBConnections = 10,
    uint64_t dbConnectionOptimalLoad = 100) {
  DBConnectionBuilder builder_(_fbb);
  builder_.add_dbConnectionOptimalLoad(dbConnectionOptimalLoad);
  builder_.add_maxDBConnections(maxDBConnections);
  builder_.add_minDBConnections(minDBConnections);
  return builder_.Finish();
}

flatbuffers::Offset<DBConnection> CreateDBConnection(flatbuffers::FlatBufferBuilder &_fbb, const DBConnectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GlogT : public flatbuffers::NativeTable {
  typedef Glog TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.GlogT";
  }
  uint32_t FLAGS_v;
  uint32_t FLAGS_max_log_size;
  uint32_t FLAGS_logtostderr;
  int32_t FLAGS_logbuflevel;
  int32_t FLAGS_stderrthreshold;
  uint32_t FLAGS_alsologtostderr;
  std::string FLAGS_vmodule;
  GlogT()
      : FLAGS_v(1),
        FLAGS_max_log_size(50),
        FLAGS_logtostderr(0),
        FLAGS_logbuflevel(0),
        FLAGS_stderrthreshold(3),
        FLAGS_alsologtostderr(0) {
  }
};

struct Glog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GlogT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GlogTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.Glog";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS_V = 4,
    VT_FLAGS_MAX_LOG_SIZE = 6,
    VT_FLAGS_LOGTOSTDERR = 8,
    VT_FLAGS_LOGBUFLEVEL = 10,
    VT_FLAGS_STDERRTHRESHOLD = 12,
    VT_FLAGS_ALSOLOGTOSTDERR = 14,
    VT_FLAGS_VMODULE = 16
  };
  uint32_t FLAGS_v() const {
    return GetField<uint32_t>(VT_FLAGS_V, 1);
  }
  bool mutate_FLAGS_v(uint32_t _FLAGS_v) {
    return SetField<uint32_t>(VT_FLAGS_V, _FLAGS_v, 1);
  }
  uint32_t FLAGS_max_log_size() const {
    return GetField<uint32_t>(VT_FLAGS_MAX_LOG_SIZE, 50);
  }
  bool mutate_FLAGS_max_log_size(uint32_t _FLAGS_max_log_size) {
    return SetField<uint32_t>(VT_FLAGS_MAX_LOG_SIZE, _FLAGS_max_log_size, 50);
  }
  uint32_t FLAGS_logtostderr() const {
    return GetField<uint32_t>(VT_FLAGS_LOGTOSTDERR, 0);
  }
  bool mutate_FLAGS_logtostderr(uint32_t _FLAGS_logtostderr) {
    return SetField<uint32_t>(VT_FLAGS_LOGTOSTDERR, _FLAGS_logtostderr, 0);
  }
  int32_t FLAGS_logbuflevel() const {
    return GetField<int32_t>(VT_FLAGS_LOGBUFLEVEL, 0);
  }
  bool mutate_FLAGS_logbuflevel(int32_t _FLAGS_logbuflevel) {
    return SetField<int32_t>(VT_FLAGS_LOGBUFLEVEL, _FLAGS_logbuflevel, 0);
  }
  int32_t FLAGS_stderrthreshold() const {
    return GetField<int32_t>(VT_FLAGS_STDERRTHRESHOLD, 3);
  }
  bool mutate_FLAGS_stderrthreshold(int32_t _FLAGS_stderrthreshold) {
    return SetField<int32_t>(VT_FLAGS_STDERRTHRESHOLD, _FLAGS_stderrthreshold, 3);
  }
  uint32_t FLAGS_alsologtostderr() const {
    return GetField<uint32_t>(VT_FLAGS_ALSOLOGTOSTDERR, 0);
  }
  bool mutate_FLAGS_alsologtostderr(uint32_t _FLAGS_alsologtostderr) {
    return SetField<uint32_t>(VT_FLAGS_ALSOLOGTOSTDERR, _FLAGS_alsologtostderr, 0);
  }
  const flatbuffers::String *FLAGS_vmodule() const {
    return GetPointer<const flatbuffers::String *>(VT_FLAGS_VMODULE);
  }
  flatbuffers::String *mutable_FLAGS_vmodule() {
    return GetPointer<flatbuffers::String *>(VT_FLAGS_VMODULE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS_V) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS_MAX_LOG_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS_LOGTOSTDERR) &&
           VerifyField<int32_t>(verifier, VT_FLAGS_LOGBUFLEVEL) &&
           VerifyField<int32_t>(verifier, VT_FLAGS_STDERRTHRESHOLD) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS_ALSOLOGTOSTDERR) &&
           VerifyOffset(verifier, VT_FLAGS_VMODULE) &&
           verifier.VerifyString(FLAGS_vmodule()) &&
           verifier.EndTable();
  }
  GlogT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GlogT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Glog> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlogT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GlogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FLAGS_v(uint32_t FLAGS_v) {
    fbb_.AddElement<uint32_t>(Glog::VT_FLAGS_V, FLAGS_v, 1);
  }
  void add_FLAGS_max_log_size(uint32_t FLAGS_max_log_size) {
    fbb_.AddElement<uint32_t>(Glog::VT_FLAGS_MAX_LOG_SIZE, FLAGS_max_log_size, 50);
  }
  void add_FLAGS_logtostderr(uint32_t FLAGS_logtostderr) {
    fbb_.AddElement<uint32_t>(Glog::VT_FLAGS_LOGTOSTDERR, FLAGS_logtostderr, 0);
  }
  void add_FLAGS_logbuflevel(int32_t FLAGS_logbuflevel) {
    fbb_.AddElement<int32_t>(Glog::VT_FLAGS_LOGBUFLEVEL, FLAGS_logbuflevel, 0);
  }
  void add_FLAGS_stderrthreshold(int32_t FLAGS_stderrthreshold) {
    fbb_.AddElement<int32_t>(Glog::VT_FLAGS_STDERRTHRESHOLD, FLAGS_stderrthreshold, 3);
  }
  void add_FLAGS_alsologtostderr(uint32_t FLAGS_alsologtostderr) {
    fbb_.AddElement<uint32_t>(Glog::VT_FLAGS_ALSOLOGTOSTDERR, FLAGS_alsologtostderr, 0);
  }
  void add_FLAGS_vmodule(flatbuffers::Offset<flatbuffers::String> FLAGS_vmodule) {
    fbb_.AddOffset(Glog::VT_FLAGS_VMODULE, FLAGS_vmodule);
  }
  explicit GlogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GlogBuilder &operator=(const GlogBuilder &);
  flatbuffers::Offset<Glog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Glog>(end);
    return o;
  }
};

inline flatbuffers::Offset<Glog> CreateGlog(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t FLAGS_v = 1,
    uint32_t FLAGS_max_log_size = 50,
    uint32_t FLAGS_logtostderr = 0,
    int32_t FLAGS_logbuflevel = 0,
    int32_t FLAGS_stderrthreshold = 3,
    uint32_t FLAGS_alsologtostderr = 0,
    flatbuffers::Offset<flatbuffers::String> FLAGS_vmodule = 0) {
  GlogBuilder builder_(_fbb);
  builder_.add_FLAGS_vmodule(FLAGS_vmodule);
  builder_.add_FLAGS_alsologtostderr(FLAGS_alsologtostderr);
  builder_.add_FLAGS_stderrthreshold(FLAGS_stderrthreshold);
  builder_.add_FLAGS_logbuflevel(FLAGS_logbuflevel);
  builder_.add_FLAGS_logtostderr(FLAGS_logtostderr);
  builder_.add_FLAGS_max_log_size(FLAGS_max_log_size);
  builder_.add_FLAGS_v(FLAGS_v);
  return builder_.Finish();
}

inline flatbuffers::Offset<Glog> CreateGlogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t FLAGS_v = 1,
    uint32_t FLAGS_max_log_size = 50,
    uint32_t FLAGS_logtostderr = 0,
    int32_t FLAGS_logbuflevel = 0,
    int32_t FLAGS_stderrthreshold = 3,
    uint32_t FLAGS_alsologtostderr = 0,
    const char *FLAGS_vmodule = nullptr) {
  auto FLAGS_vmodule__ = FLAGS_vmodule ? _fbb.CreateString(FLAGS_vmodule) : 0;
  return testapp::CreateGlog(
      _fbb,
      FLAGS_v,
      FLAGS_max_log_size,
      FLAGS_logtostderr,
      FLAGS_logbuflevel,
      FLAGS_stderrthreshold,
      FLAGS_alsologtostderr,
      FLAGS_vmodule__);
}

flatbuffers::Offset<Glog> CreateGlog(flatbuffers::FlatBufferBuilder &_fbb, const GlogT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConfigT : public flatbuffers::NativeTable {
  typedef Config TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.ConfigT";
  }
  sisl::embedded_t<DatabaseSettingsT> database;
  sisl::embedded_t<DBConnectionT> dbconnection;
  sisl::embedded_t<GlogT> glog;
  ConfigT() {
  }
};

struct Config FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConfigT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConfigTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.Config";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATABASE = 4,
    VT_DBCONNECTION = 6,
    VT_GLOG = 8
  };
  const DatabaseSettings *database() const {
    return GetPointer<const DatabaseSettings *>(VT_DATABASE);
  }
  DatabaseSettings *mutable_database() {
    return GetPointer<DatabaseSettings *>(VT_DATABASE);
  }
  const DBConnection *dbconnection() const {
    return GetPointer<const DBConnection *>(VT_DBCONNECTION);
  }
  DBConnection *mutable_dbconnection() {
    return GetPointer<DBConnection *>(VT_DBCONNECTION);
  }
  const Glog *glog() const {
    return GetPointer<const Glog *>(VT_GLOG);
  }
  Glog *mutable_glog() {
    return GetPointer<Glog *>(VT_GLOG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATABASE) &&
           verifier.VerifyTable(database()) &&
           VerifyOffset(verifier, VT_DBCONNECTION) &&
           verifier.VerifyTable(dbconnection()) &&
           VerifyOffset(verifier, VT_GLOG) &&
           verifier.VerifyTable(glog()) &&
           verifier.EndTable();
  }
  ConfigT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConfigT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Config> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_database(flatbuffers::Offset<DatabaseSettings> database) {
    fbb_.AddOffset(Config::VT_DATABASE, database);
  }
  void add_dbconnection(flatbuffers::Offset<DBConnection> dbconnection) {
    fbb_.AddOffset(Config::VT_DBCONNECTION, dbconnection);
  }
  void add_glog(flatbuffers::Offset<Glog> glog) {
    fbb_.AddOffset(Config::VT_GLOG, glog);
  }
  explicit ConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConfigBuilder &operator=(const ConfigBuilder &);
  flatbuffers::Offset<Config> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Config>(end);
    return o;
  }
};

inline flatbuffers::Offset<Config> CreateConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<DatabaseSettings> database = 0,
    flatbuffers::Offset<DBConnection> dbconnection = 0,
    flatbuffers::Offset<Glog> glog = 0) {
  ConfigBuilder builder_(_fbb);
  builder_.add_glog(glog);
  builder_.add_dbconnection(dbconnection);
  builder_.add_database(database);
  return builder_.Finish();
}

flatbuffers::Offset<Config> CreateConfig(flatbuffers::FlatBufferBuilder &_fbb, const ConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TestAppSettingsT : public flatbuffers::NativeTable {
  typedef TestAppSettings TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.TestAppSettingsT";
  }
  uint32_t version;
  sisl::embedded_t<ConfigT> config;
  TestAppSettingsT()
      : version(0) {
  }
};

struct TestAppSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TestAppSettingsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TestAppSettingsTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "testapp.TestAppSettings";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_CONFIG = 6
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  const Config *config() const {
    return GetPointer<const Config *>(VT_CONFIG);
  }
  Config *mutable_config() {
    return GetPointer<Config *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
  TestAppSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestAppSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TestAppSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestAppSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestAppSettingsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(TestAppSettings::VT_VERSION, version, 0);
  }
  void add_config(flatbuffers::Offset<Config> config) {
    fbb_.AddOffset(TestAppSettings::VT_CONFIG, config);
  }
  explicit TestAppSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TestAppSettingsBuilder &operator=(const TestAppSettingsBuilder &);
  flatbuffers::Offset<TestAppSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TestAppSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<TestAppSettings> CreateTestAppSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<Config> config = 0) {
  TestAppSettingsBuilder builder_(_fbb);
  builder_.add_config(config);
  builder_.add_version(version);
  return builder_.Finish();
}

flatbuffers::Offset<TestAppSettings> CreateTestAppSettings(flatbuffers::FlatBufferBuilder &_fbb, const TestAppSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline DatabaseSettingsT *DatabaseSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DatabaseSettingsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DatabaseSettings::UnPackTo(DatabaseSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = databaseHost(); if (_e) _o->databaseHost = _e->str(); };
  { auto _e = databasePort(); _o->databasePort = _e; };
  { auto _e = numThreads(); _o->numThreads = _e; };
}

inline flatbuffers::Offset<DatabaseSettings> DatabaseSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DatabaseSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDatabaseSettings(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DatabaseSettings> CreateDatabaseSettings(flatbuffers::FlatBufferBuilder &_fbb, const DatabaseSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DatabaseSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _databaseHost = _o->databaseHost.empty() ? 0 : _fbb.CreateString(_o->databaseHost);
  auto _databasePort = _o->databasePort;
  auto _numThreads = _o->numThreads;
  return testapp::CreateDatabaseSettings(
      _fbb,
      _databaseHost,
      _databasePort,
      _numThreads);
}

inline DBConnectionT *DBConnection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DBConnectionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DBConnection::UnPackTo(DBConnectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minDBConnections(); _o->minDBConnections = _e; };
  { auto _e = maxDBConnections(); _o->maxDBConnections = _e; };
  { auto _e = dbConnectionOptimalLoad(); _o->dbConnectionOptimalLoad = _e; };
}

inline flatbuffers::Offset<DBConnection> DBConnection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DBConnectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDBConnection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DBConnection> CreateDBConnection(flatbuffers::FlatBufferBuilder &_fbb, const DBConnectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DBConnectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minDBConnections = _o->minDBConnections;
  auto _maxDBConnections = _o->maxDBConnections;
  auto _dbConnectionOptimalLoad = _o->dbConnectionOptimalLoad;
  return testapp::CreateDBConnection(
      _fbb,
      _minDBConnections,
      _maxDBConnections,
      _dbConnectionOptimalLoad);
}

inline GlogT *Glog::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GlogT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Glog::UnPackTo(GlogT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = FLAGS_v(); _o->FLAGS_v = _e; };
  { auto _e = FLAGS_max_log_size(); _o->FLAGS_max_log_size = _e; };
  { auto _e = FLAGS_logtostderr(); _o->FLAGS_logtostderr = _e; };
  { auto _e = FLAGS_logbuflevel(); _o->FLAGS_logbuflevel = _e; };
  { auto _e = FLAGS_stderrthreshold(); _o->FLAGS_stderrthreshold = _e; };
  { auto _e = FLAGS_alsologtostderr(); _o->FLAGS_alsologtostderr = _e; };
  { auto _e = FLAGS_vmodule(); if (_e) _o->FLAGS_vmodule = _e->str(); };
}

inline flatbuffers::Offset<Glog> Glog::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlogT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGlog(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Glog> CreateGlog(flatbuffers::FlatBufferBuilder &_fbb, const GlogT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GlogT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _FLAGS_v = _o->FLAGS_v;
  auto _FLAGS_max_log_size = _o->FLAGS_max_log_size;
  auto _FLAGS_logtostderr = _o->FLAGS_logtostderr;
  auto _FLAGS_logbuflevel = _o->FLAGS_logbuflevel;
  auto _FLAGS_stderrthreshold = _o->FLAGS_stderrthreshold;
  auto _FLAGS_alsologtostderr = _o->FLAGS_alsologtostderr;
  auto _FLAGS_vmodule = _o->FLAGS_vmodule.empty() ? 0 : _fbb.CreateString(_o->FLAGS_vmodule);
  return testapp::CreateGlog(
      _fbb,
      _FLAGS_v,
      _FLAGS_max_log_size,
      _FLAGS_logtostderr,
      _FLAGS_logbuflevel,
      _FLAGS_stderrthreshold,
      _FLAGS_alsologtostderr,
      _FLAGS_vmodule);
}

inline ConfigT *Config::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConfigT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Config::UnPackTo(ConfigT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = database(); if (_e) _o->database = sisl::embedded_t<DatabaseSettingsT>(_e->UnPack(_resolver)); };
  { auto _e = dbconnection(); if (_e) _o->dbconnection = sisl::embedded_t<DBConnectionT>(_e->UnPack(_resolver)); };
  { auto _e = glog(); if (_e) _o->glog = sisl::embedded_t<GlogT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Config> Config::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConfig(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Config> CreateConfig(flatbuffers::FlatBufferBuilder &_fbb, const ConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConfigT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _database = _o->database ? CreateDatabaseSettings(_fbb, _o->database.get(), _rehasher) : 0;
  auto _dbconnection = _o->dbconnection ? CreateDBConnection(_fbb, _o->dbconnection.get(), _rehasher) : 0;
  auto _glog = _o->glog ? CreateGlog(_fbb, _o->glog.get(), _rehasher) : 0;
  return testapp::CreateConfig(
      _fbb,
      _database,
      _dbconnection,
      _glog);
}

inline TestAppSettingsT *TestAppSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TestAppSettingsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TestAppSettings::UnPackTo(TestAppSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; };
  { auto _e = config(); if (_e) _o->config = sisl::embedded_t<ConfigT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TestAppSettings> TestAppSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestAppSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestAppSettings(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TestAppSettings> CreateTestAppSettings(flatbuffers::FlatBufferBuilder &_fbb, const TestAppSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TestAppSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  auto _config = _o->config ? CreateConfig(_fbb, _o->config.get(), _rehasher) : 0;
  return testapp::CreateTestAppSettings(
      _fbb,
      _version,
      _config);
}

inline const flatbuffers::TypeTable *DatabaseSettingsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "databaseHost",
    "databasePort",
    "numThreads"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DBConnectionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "minDBConnections",
    "maxDBConnections",
    "dbConnectionOptimalLoad",
    "dbConnectionMaxLoad"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GlogTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "FLAGS_v",
    "FLAGS_max_log_size",
    "FLAGS_logtostderr",
    "FLAGS_logbuflevel",
    "FLAGS_stderrthreshold",
    "FLAGS_alsologtostderr",
    "FLAGS_vmodule"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConfigTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DatabaseSettingsTypeTable,
    DBConnectionTypeTable,
    GlogTypeTable
  };
  static const char * const names[] = {
    "database",
    "dbconnection",
    "glog"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TestAppSettingsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ConfigTypeTable
  };
  static const char * const names[] = {
    "version",
    "config"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const testapp::TestAppSettings *GetTestAppSettings(const void *buf) {
  return flatbuffers::GetRoot<testapp::TestAppSettings>(buf);
}

inline const testapp::TestAppSettings *GetSizePrefixedTestAppSettings(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<testapp::TestAppSettings>(buf);
}

inline TestAppSettings *GetMutableTestAppSettings(void *buf) {
  return flatbuffers::GetMutableRoot<TestAppSettings>(buf);
}

inline bool VerifyTestAppSettingsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<testapp::TestAppSettings>(nullptr);
}

inline bool VerifySizePrefixedTestAppSettingsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<testapp::TestAppSettings>(nullptr);
}

inline void FinishTestAppSettingsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<testapp::TestAppSettings> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTestAppSettingsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<testapp::TestAppSettings> root) {
  fbb.FinishSizePrefixed(root);
}

inline sisl::embedded_t<TestAppSettingsT> UnPackTestAppSettings(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return sisl::embedded_t<TestAppSettingsT>(GetTestAppSettings(buf)->UnPack(res));
}

}  // namespace testapp

#endif  // FLATBUFFERS_GENERATED_TESTAPPSCHEMA_TESTAPP_H_
